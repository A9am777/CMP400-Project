Texture2D depths : register(t0); //depth.w = depth value
SamplerState perPixel : register(s0);

cbuffer Particle : register(b0)
{
    float3 position; //World position
    float radius;
    
    float3 velocity;
    float glowAmount;

    float3 colour;
    float mass;

    float life;
    float3 padding;
};

struct InputType
{
    float4 position : SV_POSITION;
    float2 uv : TEXCOORD0;
    float3 normal : NORMAL;
    float3 worldPosition : POSITION0;
    float4 screenPosition : POSITION1; //Actually useable screen coords
};

float4 main(InputType input) : SV_TARGET
{
    float4 volumeCol = float4(0, 0, 0, 0);
    
    //Get the depth value of this fragment
    float depth = depths.Sample(perPixel, input.screenPosition.xy).w;
    if (input.screenPosition.z > depth) { return volumeCol; } //Return early if fail depth test
    //Analysis: this works however has aliasing issues :(
    
    float3 displacement = input.worldPosition - position; //Displacement from the centre
    float circleDisp = length(displacement);

    float falloff = 1.0f - (circleDisp / radius); //From 1->0 from centre to circumference
    falloff *= pow(falloff, 1.0f - glowAmount); //Change falloff curve to be reliant on power proportional to glow

    falloff = max(falloff, 0.0f); //Clamp to +ve only
    
    //Add this particle's volume colour
    volumeCol = float4(mul(colour, falloff), 1.0f);
    
	return volumeCol;
}