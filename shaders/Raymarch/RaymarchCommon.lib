#ifndef RAYMARCHCOMMON_H
#define RAYMARCHCOMMON_H
#include "../Utility/Globals.lib"
#include "../Utility/MeshCommon.lib"

struct MarchVolumeDispatchInfo
{
  float outputHorizontalStep; // View step per horizontal thread
  float outputVerticalStep; // View step per vertical thread
  float initialZStep; // Distance to initially jump in Z
  float marchZStep; // Distance to typically jump in Z
 
  uint iterations; // Number of volume steps to take
  float texelDensity; // The density of the volume texture in world space
  float pixelRadius; // The radius a pixel occupies in world space
  float pixelRadiusDelta; // The linear change of pixel radius with world depth
  
  float4x4 localVolumeTransform; // Transforms from world space to volume space
  float4 volumeSize; // The scale of the volume in world space
};

struct BasicOptics
{
  float4 anisotropicForwardTerms; // Forward anisotropic parameters per major light component
  float4 anisotropicBackwardTerms; // Backward anisotropic parameters per major light component
  float4 phaseBlendWeightTerms; // Per component phase blend factor
  
  float scatterAngstromExponent;
  float absorptionAngstromExponent;
  float attenuationFactor; // Scales optical depth
  float powderCoefficient; // Beers-Powder scaling factor
  float4x4 spectralWavelengths; // Wavelengths to integrate over
  float4x4 spectralWeights; // Spectral integration weights
  
  float4 ambientFraction;
  uint4 flags;
};

struct MarchParams
{
  float initialStep;
  float marchZStep;
  uint iterations;
  bool mask;
};

struct Ray
{
  float4 pos;
  float4 dir;
  float4 colour;
  float travelDistance; // World distance the ray has traversed
};

struct Sphere
{
  float4 pos;
  float sqrRadius;
};

struct Cube
{
  float4 pos;
  float3 size;
};

struct RectangleIntegrator // Midpoint rule
{
  float total;
  uint count;
};

struct SimpsonsIntegrator // Simpsons rule
{
  float firstTerm;
  float lastTerm;
  float odds;
  float evens;
  uint count;
};

struct SimpsonsIntegrator4 // Simpsons rule (x4)
{
  float4 firstTerms;
  float4 lastTerms;
  float4 odds;
  float4 evens;
  uint count;
};

static float PI = radians(180.);

void append4(inout SimpsonsIntegrator4 inte, float4 values)
{
  inte.lastTerms = values;
  if (inte.count % 2 == 0)
  {
    inte.evens += values;
  }
  else
  {
    inte.odds += values;
  }
  
  ++inte.count;
}

float4 integrate4(inout SimpsonsIntegrator4 inte, float range)
{
  float stepSize = range / float(inte.count);
  float4 results = inte.firstTerms + inte.lastTerms;
  results += 4. * inte.odds;
  results += 2. * (inte.evens - inte.lastTerms);
  return results * stepSize / 3.;
}

void append(inout SimpsonsIntegrator inte, float value)
{
  inte.lastTerm = value;
  if (inte.count % 2 == 0)
  {
    inte.evens += value;
  }
  else
  {
    inte.odds += value;
  }
  
  ++inte.count;
}

float integrate(inout SimpsonsIntegrator inte, float range)
{
  float stepSize = range / float(inte.count);
  float result = inte.firstTerm + inte.lastTerm;
  result += 4. * inte.odds;
  result += 2 * (inte.evens - inte.lastTerm);
  return result * stepSize / 3.;
}

void append(inout RectangleIntegrator inte, float value)
{
  inte.total += value;
  inte.count++;
}

float integrate(inout RectangleIntegrator inte)
{
  return inte.total;
}

#endif