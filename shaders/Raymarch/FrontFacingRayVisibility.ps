#include "../Utility/MeshCommon.lib"
#include "../Lighting/GBuffer.lib"

struct InputType
{
  float4 position : SV_POSITION;
  float4 screenPosition : POSITION0; // Actually normalised dev coords
  float2 uv : TEXCOORD0;
  float3 normal : NORMAL;
  float3 worldPosition : POSITION1;
};

// Converts [-1, 1] to [0, 1]
float signedToNorm(float norm)
{
  return norm * .5 + .5;
}

// This shader masks the frontface of a bounding box (via occlusion) and additively blends the determined depth
float4 main(InputType input) : SV_Target
{
  // Additive, combat initial undefined -ve value
  float4 output = float4(0., .0, .0, 1.);
  
  // The bound depth. Note that a camera *within* the bounds should exhibit different behaviour
  //output.x += input.screenPosition.z;
  
  #if !APPLY_CONE_TRACE
  // It is beneficial to utilise a rasterized screen position for raymarching
  // (this shader always passes so this operation is performed here over the front facing pass)
  //output.z = input.screenPosition.x;
  //output.w = signedToNorm(input.screenPosition.y) + 1.; // Pack to bypass alpha test
  #endif
  
  return output;
}